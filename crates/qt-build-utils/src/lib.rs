// SPDX-FileCopyrightText: 2022 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
// SPDX-FileContributor: Be Wilson <be.wilson@kdab.com>
//
// SPDX-License-Identifier: MIT OR Apache-2.0

#![deny(missing_docs)]

//! This crate provides information about the Qt installation and can invoke Qt's
//! [moc](https://doc.qt.io/qt-6/moc.html) code generator. This crate does not build
//! any C++ code on its own. It is intended to be used in [build.rs scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)
//! together with
//! [cc](https://docs.rs/cc/latest/cc/),
//! [cxx_build](https://docs.rs/cxx-build/latest/cxx_build/), or
//! [cpp_build](https://docs.rs/cpp_build/latest/cpp_build/).

#![allow(clippy::too_many_arguments)]

mod error;
pub use error::QtBuildError;

mod initializer;
pub use initializer::Initializer;

mod installation;
pub use installation::QtInstallation;

#[cfg(feature = "qmake")]
pub use installation::qmake::QtInstallationQMake;

#[cfg(feature = "qmake")]
mod parse_cflags;

mod tool;
pub use tool::{
    MocArguments, MocProducts, QmlCacheArguments, QmlCacheProducts, QtTool, QtToolMoc,
    QtToolQmlCacheGen, QtToolQmlTypeRegistrar, QtToolRcc,
};

mod utils;

use std::{
    env,
    fs::File,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};

use semver::Version;

fn command_help_output(command: &str) -> std::io::Result<std::process::Output> {
    Command::new(command).args(["--help"]).output()
}

/// Linking executables (including tests) with Cargo that link to Qt fails to link with GNU ld.bfd,
/// which is the default on most Linux distributions, so use GNU ld.gold, lld, or mold instead.
/// If you are using a C++ build system such as CMake to do the final link of the executable, you do
/// not need to call this function.
///
/// With Apple devices we set -fapple-link-rtlib as we build with -nodefaultlibs
/// otherwise we cannot user helpers from the compiler runtime in Qt
///
/// This does nothing on non-Unix platforms.
pub fn setup_linker() {
    if env::var("CARGO_CFG_UNIX").is_err() {
        return;
    }

    if let Ok(vendor) = env::var("CARGO_CFG_TARGET_VENDOR") {
        if vendor == "apple" {
            // Tell clang link to clang_rt as we build with -nodefaultlibs
            // otherwise we cannot use helpers from the compiler runtime in Qt
            println!("cargo::rustc-link-arg=-fapple-link-rtlib");
        }
    }

    let flags = env::var("CARGO_ENCODED_RUSTFLAGS").unwrap();
    // Don't override custom flags
    if !flags.contains("-fuse-ld") {
        // ld is the system default linker. On Linux, this is usually GNU ld.bfd, but it may be symlinked to another
        // linker. On macOS, Xcode ships lld with the executable named ld.
        let ld_help = String::from_utf8(
            command_help_output("ld")
                .expect("Could not run ld command")
                .stdout,
        )
        .unwrap();
        // bfd supports some exotic targets that other linkers do not.
        let ld_is_bfd = ld_help.contains("symbolsrec")
            || ld_help.contains("verilog")
            || ld_help.contains("tekhex");

        // Whatever linker is being used that's not bfd will likely work.
        if !ld_is_bfd {
            return;
        }

        // mold is fastest, but specifing mold with -fuse-ld requires GCC >= 12 or Clang.
        // Unfortunately cargo does not provide a means to set the linker driver via build scripts,
        // so linking would fail trying to use -fuse-ld=mold with GCC < 12 even if clang is installed.
        // So, prefer lld and gold to mold for robustness on the widest range of systems.
        // mold can still be used by manually specifying it in ~/.cargo/config.toml or the RUSTFLAGS environment variable.
        if command_help_output("lld").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=lld");
        } else if command_help_output("ld.gold").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=gold");
        } else if command_help_output("mold").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=mold");
        } else {
            println!("cargo::warning=Neither mold, lld, nor gold linkers were found. Linking with GNU ld.bfd will likely fail.");
        }
    }
}

/// Paths to C++ files generated by [QtBuild::register_qml_module]
pub struct QmlModuleRegistrationFiles {
    /// File generated by [rcc](https://doc.qt.io/qt-6/rcc.html) for the QML plugin. The compiled static library
    /// must be linked with [+whole-archive](https://doc.rust-lang.org/rustc/command-line-arguments.html#linking-modifiers-whole-archive)
    /// or the linker will discard the generated static variables because they are not referenced from `main`.
    pub rcc: PathBuf,
    /// Files generated by [qmlcachegen](https://doc.qt.io/qt-6/qtqml-qtquick-compiler-tech.html). Must be linked with `+whole-archive`.
    pub qmlcachegen: Vec<PathBuf>,
    /// File generated by [qmltyperegistrar](https://www.qt.io/blog/qml-type-registration-in-qt-5.15) CLI tool.
    pub qmltyperegistrar: Option<PathBuf>,
    /// File with generated [QQmlEngineExtensionPlugin](https://doc.qt.io/qt-6/qqmlengineextensionplugin.html) that calls the function generated by qmltyperegistrar.
    pub plugin: PathBuf,
    /// Initializer that automatically registers the QQmlExtensionPlugin at startup.
    pub plugin_init: Initializer,
    /// An optional include path that should be included
    pub include_path: Option<PathBuf>,
}

/// Helper for build.rs scripts using Qt
/// ```
/// let qt_modules = vec!["Core", "Gui"]
///     .iter()
///     .map(|m| String::from(*m))
///     .collect();
/// let qtbuild = qt_build_utils::QtBuild::new(qt_modules).expect("Could not find Qt installation");
/// ```
pub struct QtBuild {
    qt_installation: Box<dyn QtInstallation>,
    qt_modules: Vec<String>,
}

impl QtBuild {
    /// Create a [QtBuild] using the default [QtInstallation] (currently uses [QtInstallationQMake])
    /// and specify which Qt modules you are linking, ommitting the `Qt` prefix (`"Core"`
    /// rather than `"QtCore"`).
    ///
    /// Currently this function is only available when the `qmake` feature is enabled.
    /// Use [Self::with_installation] to create a [QtBuild] with a custom [QtInstallation].
    #[cfg(feature = "qmake")]
    pub fn new(qt_modules: Vec<String>) -> anyhow::Result<Self> {
        let qt_installation = Box::new(QtInstallationQMake::new()?);
        Ok(Self::with_installation(qt_installation, qt_modules))
    }

    /// Create a [QtBuild] using the given [QtInstallation] and specify which
    /// Qt modules you are linking, ommitting the `Qt` prefix (`"Core"` rather than `"QtCore"`).
    pub fn with_installation(
        qt_installation: Box<dyn QtInstallation>,
        mut qt_modules: Vec<String>,
    ) -> Self {
        if qt_modules.is_empty() {
            qt_modules.push("Core".to_string());
        }

        Self {
            qt_installation,
            qt_modules,
        }
    }

    /// Tell Cargo to link each Qt module.
    pub fn cargo_link_libraries(&self, builder: &mut cc::Build) {
        self.qt_installation.link_modules(builder, &self.qt_modules);
    }

    /// Get the include paths for Qt, including Qt module subdirectories. This is intended
    /// to be passed to whichever tool you are using to invoke the C++ compiler.
    pub fn include_paths(&self) -> Vec<PathBuf> {
        self.qt_installation.include_paths(&self.qt_modules)
    }

    /// Version of the detected Qt installation
    pub fn version(&self) -> Version {
        self.qt_installation.version()
    }

    /// Create a [QtToolMoc] for this [QtBuild]
    ///
    /// This allows for using [moc](https://doc.qt.io/qt-6/moc.html)
    pub fn moc(&mut self) -> QtToolMoc {
        QtToolMoc::new(self.qt_installation.as_ref(), &self.qt_modules)
    }

    /// Generate C++ files to automatically register a QML module at build time using the JSON output from [moc](Self::moc).
    ///
    /// This generates a [qmldir file](https://doc.qt.io/qt-6/qtqml-modules-qmldir.html) for the QML module.
    /// The `qml_files` and `qrc_files` are registered with the [Qt Resource System](https://doc.qt.io/qt-6/resources.html) in
    /// the [default QML import path](https://doc.qt.io/qt-6/qtqml-syntax-imports.html#qml-import-path) `qrc:/qt/qml/uri/of/module/`.
    ///
    /// When using Qt 6, this will [run qmlcachegen](https://doc.qt.io/qt-6/qtqml-qtquick-compiler-tech.html) to compile the specified .qml files ahead-of-time.
    pub fn register_qml_module(
        &mut self,
        metatypes_json: &[impl AsRef<Path>],
        uri: &str,
        version_major: usize,
        version_minor: usize,
        plugin_name: &str,
        qml_files: &[impl AsRef<Path>],
        qrc_files: &[impl AsRef<Path>],
    ) -> QmlModuleRegistrationFiles {
        let qml_uri_dirs = uri.replace('.', "/");

        let out_dir = env::var("OUT_DIR").unwrap();
        let qt_build_utils_dir = PathBuf::from(format!("{out_dir}/qt-build-utils"));
        std::fs::create_dir_all(&qt_build_utils_dir).expect("Could not create qt_build_utils dir");

        let qml_module_dir = qt_build_utils_dir.join("qml_modules").join(&qml_uri_dirs);
        std::fs::create_dir_all(&qml_module_dir).expect("Could not create QML module directory");

        let qml_uri_underscores = uri.replace('.', "_");
        let qmltypes_path = qml_module_dir.join("plugin.qmltypes");
        let plugin_class_name = format!("{qml_uri_underscores}_plugin");

        // Generate qmldir file
        let qmldir_file_path = qml_module_dir.join("qmldir");
        {
            let mut qmldir = File::create(&qmldir_file_path).expect("Could not create qmldir file");
            write!(
                qmldir,
                "module {uri}
optional plugin {plugin_name}
classname {plugin_class_name}
typeinfo plugin.qmltypes
prefer :/qt/qml/{qml_uri_dirs}/
"
            )
            .expect("Could not write qmldir file");
        }

        // Generate .qrc file and run rcc on it
        let qrc_path =
            qml_module_dir.join(format!("qml_module_resources_{qml_uri_underscores}.qrc"));
        {
            fn qrc_file_line(file_path: &impl AsRef<Path>) -> String {
                let path_display = file_path.as_ref().display();
                format!(
                    "    <file alias=\"{}\">{}</file>\n",
                    path_display,
                    std::fs::canonicalize(file_path)
                        .unwrap_or_else(|_| panic!("Could not canonicalize path {}", path_display))
                        .display()
                )
            }

            let mut qml_files_qrc = String::new();
            for file_path in qml_files {
                qml_files_qrc.push_str(&qrc_file_line(file_path));
            }
            for file_path in qrc_files {
                qml_files_qrc.push_str(&qrc_file_line(file_path));
            }

            let mut qrc = File::create(&qrc_path).expect("Could not create qrc file");
            let qml_module_dir_str = qml_module_dir.to_str().unwrap();
            write!(
                qrc,
                r#"<RCC>
<qresource prefix="/">
    <file alias="/qt/qml/{qml_uri_dirs}">{qml_module_dir_str}</file>
</qresource>
<qresource prefix="/qt/qml/{qml_uri_dirs}">
{qml_files_qrc}
    <file alias="qmldir">{qml_module_dir_str}/qmldir</file>
</qresource>
</RCC>
"#
            )
            .expect("Could note write qrc file");
        }

        // Run qmlcachegen
        // qmlcachegen needs to be run once for each .qml file with --resource-path,
        // then once for the module with --resource-name.
        let mut qmlcachegen_file_paths = Vec::new();

        // qmlcachegen has a different CLI in Qt 5, so only support Qt >= 6
        if self.qt_installation.version().major >= 6 {
            let qml_cache_args = QmlCacheArguments {
                uri: uri.to_string(),
                qmldir_path: qmldir_file_path,
                qmldir_qrc_path: qrc_path.clone(),
            };
            let mut qml_resource_paths = Vec::new();
            for file in qml_files {
                let result = QtToolQmlCacheGen::new(self.qt_installation.as_ref())
                    .compile(qml_cache_args.clone(), file);
                qmlcachegen_file_paths.push(result.qml_cache_path);
                qml_resource_paths.push(result.qml_resource_path);
            }

            // If there are no QML files there is nothing for qmlcachegen to run with
            if !qml_files.is_empty() {
                qmlcachegen_file_paths.push(
                    QtToolQmlCacheGen::new(self.qt_installation.as_ref())
                        .compile_loader(qml_cache_args.clone(), &qml_resource_paths),
                );
            }
        }

        let qml_plugin_dir = PathBuf::from(format!("{out_dir}/qt-build-utils/qml_plugin"));
        std::fs::create_dir_all(&qml_plugin_dir).expect("Could not create qml_plugin dir");

        // Run qmltyperegistrar over the meta types
        let qmltyperegistrar_path = self.qmltyperegistrar().compile(
            metatypes_json,
            qmltypes_path,
            uri,
            Version::new(version_major as u64, version_minor as u64, 0),
        );

        // Generate QQmlEngineExtensionPlugin
        let qml_plugin_cpp_path = qml_plugin_dir.join(format!("{plugin_class_name}.cpp"));
        let include_path;
        {
            let mut declarations = Vec::default();
            let mut usages = Vec::default();

            let mut generate_usage = |return_type: &str, function_name: &str| {
                declarations.push(format!("extern {return_type} {function_name}();"));
                usages.push(format!("volatile auto {function_name}_usage = &{function_name};\nQ_UNUSED({function_name}_usage);"));
            };

            // This function is generated by qmltyperegistrar
            generate_usage("void", &format!("qml_register_types_{qml_uri_underscores}"));
            generate_usage(
                "int",
                &format!("qInitResources_qml_module_resources_{qml_uri_underscores}_qrc"),
            );

            if !qml_files.is_empty() && !qmlcachegen_file_paths.is_empty() {
                generate_usage(
                    "int",
                    &format!("qInitResources_qmlcache_{qml_uri_underscores}"),
                );
            }
            let declarations = declarations.join("\n");
            let usages = usages.join("\n");

            std::fs::write(
                &qml_plugin_cpp_path,
                format!(
                    r#"
#include <QtQml/qqmlextensionplugin.h>

// TODO: Add missing handling for GHS (Green Hills Software compiler) that is in
// https://code.qt.io/cgit/qt/qtbase.git/plain/src/corelib/global/qtsymbolmacros.h
{declarations}

class {plugin_class_name} : public QQmlEngineExtensionPlugin
{{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QQmlEngineExtensionInterface")

public:
    {plugin_class_name}(QObject *parent = nullptr) : QQmlEngineExtensionPlugin(parent)
    {{
        {usages}
    }}
}};

// The moc-generated cpp file doesn't compile on its own; it needs to be #included here.
#include "moc_{plugin_class_name}.cpp.cpp"
"#,
                ),
            )
            .expect("Failed to write plugin definition");

            let moc_product = self.moc().compile(
                &qml_plugin_cpp_path,
                MocArguments::default().uri(uri.to_owned()),
            );
            // Pass the include directory of the moc file to the caller
            include_path = moc_product.cpp.parent().map(|path| path.to_path_buf());

            // Generate Initializer for static QQmlExtensionPlugin
            let plugin_init = Initializer {
                file: None,
                init_call: None,
                init_declaration: Some(format!(
                    r#"
#include <QtPlugin>
Q_IMPORT_PLUGIN({plugin_class_name});
"#
                )),
            };

            let rcc = self.rcc().compile(&qrc_path);
            QmlModuleRegistrationFiles {
                // The rcc file is automatically initialized when importing the plugin.
                // so we don't need to treat it like an initializer here.
                rcc: rcc.file.unwrap(),
                qmlcachegen: qmlcachegen_file_paths,
                qmltyperegistrar: qmltyperegistrar_path,
                plugin: qml_plugin_cpp_path,
                plugin_init,
                include_path,
            }
        }
    }

    /// Create a [QtToolRcc] for this [QtBuild]
    ///
    /// This allows for using [rcc](https://doc.qt.io/qt-6/resources.html)
    pub fn rcc(&self) -> QtToolRcc {
        QtToolRcc::new(self.qt_installation.as_ref())
    }

    /// Create a [QtToolQmlTypeRegistrar] for this [QtBuild]
    pub fn qmltyperegistrar(&self) -> QtToolQmlTypeRegistrar {
        QtToolQmlTypeRegistrar::new(self.qt_installation.as_ref())
    }
}
