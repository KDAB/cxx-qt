// SPDX-FileCopyrightText: 2022 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
// SPDX-FileContributor: Be Wilson <be.wilson@kdab.com>
//
// SPDX-License-Identifier: MIT OR Apache-2.0

#![deny(missing_docs)]

//! This crate provides information about the Qt installation and can invoke Qt's
//! [moc](https://doc.qt.io/qt-6/moc.html) code generator. This crate does not build
//! any C++ code on its own. It is intended to be used in [build.rs scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)
//! together with
//! [cc](https://docs.rs/cc/latest/cc/),
//! [cxx_build](https://docs.rs/cxx-build/latest/cxx_build/), or
//! [cpp_build](https://docs.rs/cpp_build/latest/cpp_build/).

#![allow(clippy::too_many_arguments)]

mod error;
pub use error::QtBuildError;

mod initializer;
pub use initializer::Initializer;

mod installation;
pub use installation::QtInstallation;

#[cfg(feature = "qmake")]
pub use installation::qmake::QtInstallationQMake;

#[cfg(feature = "qmake")]
mod parse_cflags;

mod tool;
pub use tool::QtTool;

mod utils;

use std::{
    env,
    fs::File,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};

use semver::Version;

fn command_help_output(command: &str) -> std::io::Result<std::process::Output> {
    Command::new(command).args(["--help"]).output()
}

/// Linking executables (including tests) with Cargo that link to Qt fails to link with GNU ld.bfd,
/// which is the default on most Linux distributions, so use GNU ld.gold, lld, or mold instead.
/// If you are using a C++ build system such as CMake to do the final link of the executable, you do
/// not need to call this function.
///
/// With Apple devices we set -fapple-link-rtlib as we build with -nodefaultlibs
/// otherwise we cannot user helpers from the compiler runtime in Qt
///
/// This does nothing on non-Unix platforms.
pub fn setup_linker() {
    if env::var("CARGO_CFG_UNIX").is_err() {
        return;
    }

    if let Ok(vendor) = env::var("CARGO_CFG_TARGET_VENDOR") {
        if vendor == "apple" {
            // Tell clang link to clang_rt as we build with -nodefaultlibs
            // otherwise we cannot use helpers from the compiler runtime in Qt
            println!("cargo::rustc-link-arg=-fapple-link-rtlib");
        }
    }

    let flags = env::var("CARGO_ENCODED_RUSTFLAGS").unwrap();
    // Don't override custom flags
    if !flags.contains("-fuse-ld") {
        // ld is the system default linker. On Linux, this is usually GNU ld.bfd, but it may be symlinked to another
        // linker. On macOS, Xcode ships lld with the executable named ld.
        let ld_help = String::from_utf8(
            command_help_output("ld")
                .expect("Could not run ld command")
                .stdout,
        )
        .unwrap();
        // bfd supports some exotic targets that other linkers do not.
        let ld_is_bfd = ld_help.contains("symbolsrec")
            || ld_help.contains("verilog")
            || ld_help.contains("tekhex");

        // Whatever linker is being used that's not bfd will likely work.
        if !ld_is_bfd {
            return;
        }

        // mold is fastest, but specifing mold with -fuse-ld requires GCC >= 12 or Clang.
        // Unfortunately cargo does not provide a means to set the linker driver via build scripts,
        // so linking would fail trying to use -fuse-ld=mold with GCC < 12 even if clang is installed.
        // So, prefer lld and gold to mold for robustness on the widest range of systems.
        // mold can still be used by manually specifying it in ~/.cargo/config.toml or the RUSTFLAGS environment variable.
        if command_help_output("lld").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=lld");
        } else if command_help_output("ld.gold").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=gold");
        } else if command_help_output("mold").is_ok() {
            println!("cargo::rustc-link-arg=-fuse-ld=mold");
        } else {
            println!("cargo::warning=Neither mold, lld, nor gold linkers were found. Linking with GNU ld.bfd will likely fail.");
        }
    }
}

/// Paths to files generated by [QtBuild::moc]
pub struct MocProducts {
    /// Generated C++ file
    pub cpp: PathBuf,
    /// Generated JSON file
    pub metatypes_json: PathBuf,
}

/// Arguments for a Qt moc invocation.
/// See: [QtBuild::moc]
#[derive(Default, Clone)]
pub struct MocArguments {
    uri: Option<String>,
    include_paths: Vec<PathBuf>,
}

impl MocArguments {
    /// Should be passed if the input_file is part of a QML module
    pub fn uri(mut self, uri: String) -> Self {
        self.uri = Some(uri);
        self
    }

    /// Additional include path to pass to moc
    pub fn include_path(mut self, include_path: PathBuf) -> Self {
        self.include_paths.push(include_path);
        self
    }

    /// Additional include paths to pass to moc.
    pub fn include_paths(mut self, mut include_paths: Vec<PathBuf>) -> Self {
        self.include_paths.append(&mut include_paths);
        self
    }
}

/// Paths to C++ files generated by [QtBuild::register_qml_module]
pub struct QmlModuleRegistrationFiles {
    /// File generated by [rcc](https://doc.qt.io/qt-6/rcc.html) for the QML plugin. The compiled static library
    /// must be linked with [+whole-archive](https://doc.rust-lang.org/rustc/command-line-arguments.html#linking-modifiers-whole-archive)
    /// or the linker will discard the generated static variables because they are not referenced from `main`.
    pub rcc: PathBuf,
    /// Files generated by [qmlcachegen](https://doc.qt.io/qt-6/qtqml-qtquick-compiler-tech.html). Must be linked with `+whole-archive`.
    pub qmlcachegen: Vec<PathBuf>,
    /// File generated by [qmltyperegistrar](https://www.qt.io/blog/qml-type-registration-in-qt-5.15) CLI tool.
    pub qmltyperegistrar: PathBuf,
    /// File with generated [QQmlEngineExtensionPlugin](https://doc.qt.io/qt-6/qqmlengineextensionplugin.html) that calls the function generated by qmltyperegistrar.
    pub plugin: PathBuf,
    /// Initializer that automatically registers the QQmlExtensionPlugin at startup.
    pub plugin_init: Initializer,
    /// An optional include path that should be included
    pub include_path: Option<PathBuf>,
}

/// Helper for build.rs scripts using Qt
/// ```
/// let qt_modules = vec!["Core", "Gui"]
///     .iter()
///     .map(|m| String::from(*m))
///     .collect();
/// let qtbuild = qt_build_utils::QtBuild::new_with_default_installation(qt_modules).expect("Could not find Qt installation");
/// ```
pub struct QtBuild {
    qt_installation: Box<dyn QtInstallation>,
    qt_modules: Vec<String>,
}

impl QtBuild {
    /// Create a [QtBuild] using the default [QtInstallation] (currently uses [QtInstallationQMake])
    /// and specify which Qt modules you are linking, ommitting the `Qt` prefix (`"Core"`
    /// rather than `"QtCore"`).
    //
    // TODO: is there a better name for this method or a sane way to create a default QtInstallation?
    pub fn new_with_default_installation(qt_modules: Vec<String>) -> anyhow::Result<Self> {
        #[cfg(feature = "qmake")]
        let qt_installation = Box::new(QtInstallationQMake::new()?);
        #[cfg(not(feature = "qmake"))]
        unsupported!("Only qmake feature is supported");

        Ok(Self::new(qt_installation, qt_modules))
    }

    /// Create a [QtBuild] using the given [QtInstallation] and specify which
    /// Qt modules you are linking, ommitting the `Qt` prefix (`"Core"` rather than `"QtCore"`).
    pub fn new(qt_installation: Box<dyn QtInstallation>, mut qt_modules: Vec<String>) -> Self {
        if qt_modules.is_empty() {
            qt_modules.push("Core".to_string());
        }

        Self {
            qt_installation,
            qt_modules,
        }
    }

    /// Tell Cargo to link each Qt module.
    pub fn cargo_link_libraries(&self, builder: &mut cc::Build) {
        self.qt_installation.link_modules(builder, &self.qt_modules);
    }

    /// Get the include paths for Qt, including Qt module subdirectories. This is intended
    /// to be passed to whichever tool you are using to invoke the C++ compiler.
    pub fn include_paths(&self) -> Vec<PathBuf> {
        self.qt_installation.include_paths(&self.qt_modules)
    }

    /// Version of the detected Qt installation
    pub fn version(&self) -> Version {
        self.qt_installation.version()
    }

    /// Run moc on a C++ header file and save the output into [cargo's OUT_DIR](https://doc.rust-lang.org/cargo/reference/environment-variables.html).
    /// The return value contains the path to the generated C++ file, which can then be passed to [cc::Build::files](https://docs.rs/cc/latest/cc/struct.Build.html#method.file),
    /// as well as the path to the generated metatypes.json file, which can be passed to [register_qml_module](Self::register_qml_module).
    ///
    pub fn moc(&mut self, input_file: impl AsRef<Path>, arguments: MocArguments) -> MocProducts {
        let moc_executable = self
            .qt_installation
            .try_find_tool(QtTool::Moc)
            .expect("Could not find moc");
        let input_path = input_file.as_ref();

        // Put all the moc files into one place, this can then be added to the include path
        let moc_dir = PathBuf::from(format!(
            "{}/qt-build-utils/moc",
            env::var("OUT_DIR").unwrap()
        ));
        std::fs::create_dir_all(&moc_dir).expect("Could not create moc dir");
        let output_path = moc_dir.join(format!(
            "moc_{}.cpp",
            input_path.file_name().unwrap().to_str().unwrap()
        ));

        let metatypes_json_path = PathBuf::from(&format!("{}.json", output_path.display()));

        let mut include_args = vec![];
        // Qt includes
        for include_path in self
            .include_paths()
            .iter()
            .chain(arguments.include_paths.iter())
        {
            include_args.push(format!("-I{}", include_path.display()));
        }

        let mut cmd = Command::new(moc_executable);

        if let Some(uri) = arguments.uri {
            cmd.arg(format!("-Muri={uri}"));
        }

        cmd.args(include_args);
        cmd.arg(input_path.to_str().unwrap())
            .arg("-o")
            .arg(output_path.to_str().unwrap())
            .arg("--output-json");
        let cmd = cmd
            .output()
            .unwrap_or_else(|_| panic!("moc failed for {}", input_path.display()));

        if !cmd.status.success() {
            panic!(
                "moc failed for {}:\n{}",
                input_path.display(),
                String::from_utf8_lossy(&cmd.stderr)
            );
        }

        MocProducts {
            cpp: output_path,
            metatypes_json: metatypes_json_path,
        }
    }

    /// Generate C++ files to automatically register a QML module at build time using the JSON output from [moc](Self::moc).
    ///
    /// This generates a [qmldir file](https://doc.qt.io/qt-6/qtqml-modules-qmldir.html) for the QML module.
    /// The `qml_files` and `qrc_files` are registered with the [Qt Resource System](https://doc.qt.io/qt-6/resources.html) in
    /// the [default QML import path](https://doc.qt.io/qt-6/qtqml-syntax-imports.html#qml-import-path) `qrc:/qt/qml/uri/of/module/`.
    ///
    /// When using Qt 6, this will [run qmlcachegen](https://doc.qt.io/qt-6/qtqml-qtquick-compiler-tech.html) to compile the specified .qml files ahead-of-time.
    pub fn register_qml_module(
        &mut self,
        metatypes_json: &[impl AsRef<Path>],
        uri: &str,
        version_major: usize,
        version_minor: usize,
        plugin_name: &str,
        qml_files: &[impl AsRef<Path>],
        qrc_files: &[impl AsRef<Path>],
    ) -> QmlModuleRegistrationFiles {
        let qmltyperegistrar_executable = self
            .qt_installation
            .try_find_tool(QtTool::QmlTypeRegistrar)
            .expect("Could not find qmltyperegistrar");
        // qmlcachegen has a different CLI in Qt 5, so only support Qt >= 6
        let qmlcachegen_executable = if self.qt_installation.version().major >= 6 {
            Some(
                self.qt_installation
                    .try_find_tool(QtTool::QmlCacheGen)
                    .expect("Could not find qmlcachegen"),
            )
        } else {
            None
        };

        let qml_uri_dirs = uri.replace('.', "/");

        let out_dir = env::var("OUT_DIR").unwrap();
        let qt_build_utils_dir = PathBuf::from(format!("{out_dir}/qt-build-utils"));
        std::fs::create_dir_all(&qt_build_utils_dir).expect("Could not create qt_build_utils dir");

        let qml_module_dir = qt_build_utils_dir.join("qml_modules").join(&qml_uri_dirs);
        std::fs::create_dir_all(&qml_module_dir).expect("Could not create QML module directory");

        let qml_uri_underscores = uri.replace('.', "_");
        let qmltypes_path = qml_module_dir.join("plugin.qmltypes");
        let plugin_class_name = format!("{qml_uri_underscores}_plugin");

        // Generate qmldir file
        let qmldir_file_path = qml_module_dir.join("qmldir");
        {
            let mut qmldir = File::create(&qmldir_file_path).expect("Could not create qmldir file");
            write!(
                qmldir,
                "module {uri}
optional plugin {plugin_name}
classname {plugin_class_name}
typeinfo plugin.qmltypes
prefer :/qt/qml/{qml_uri_dirs}/
"
            )
            .expect("Could not write qmldir file");
        }

        // Generate .qrc file and run rcc on it
        let qrc_path =
            qml_module_dir.join(format!("qml_module_resources_{qml_uri_underscores}.qrc"));
        {
            fn qrc_file_line(file_path: &impl AsRef<Path>) -> String {
                let path_display = file_path.as_ref().display();
                format!(
                    "    <file alias=\"{}\">{}</file>\n",
                    path_display,
                    std::fs::canonicalize(file_path)
                        .unwrap_or_else(|_| panic!("Could not canonicalize path {}", path_display))
                        .display()
                )
            }

            let mut qml_files_qrc = String::new();
            for file_path in qml_files {
                qml_files_qrc.push_str(&qrc_file_line(file_path));
            }
            for file_path in qrc_files {
                qml_files_qrc.push_str(&qrc_file_line(file_path));
            }

            let mut qrc = File::create(&qrc_path).expect("Could not create qrc file");
            let qml_module_dir_str = qml_module_dir.to_str().unwrap();
            write!(
                qrc,
                r#"<RCC>
<qresource prefix="/">
    <file alias="/qt/qml/{qml_uri_dirs}">{qml_module_dir_str}</file>
</qresource>
<qresource prefix="/qt/qml/{qml_uri_dirs}">
{qml_files_qrc}
    <file alias="qmldir">{qml_module_dir_str}/qmldir</file>
</qresource>
</RCC>
"#
            )
            .expect("Could note write qrc file");
        }

        // Run qmlcachegen
        // qmlcachegen needs to be run once for each .qml file with --resource-path,
        // then once for the module with --resource-name.
        let mut qmlcachegen_file_paths = Vec::new();
        if let Some(qmlcachegen_executable) = &qmlcachegen_executable {
            let qmlcachegen_dir = qt_build_utils_dir.join("qmlcachegen").join(&qml_uri_dirs);
            std::fs::create_dir_all(&qmlcachegen_dir)
                .expect("Could not create qmlcachegen directory for QML module");

            let common_args = [
                "-i".to_string(),
                qmldir_file_path.to_string_lossy().to_string(),
                "--resource".to_string(),
                qrc_path.to_string_lossy().to_string(),
            ];

            let mut qml_file_qrc_paths = Vec::new();
            for file in qml_files {
                let qrc_resource_path =
                    format!("/qt/qml/{qml_uri_dirs}/{}", file.as_ref().display());

                let qml_compiled_file = qmlcachegen_dir.join(format!(
                    "{}.cpp",
                    file.as_ref().file_name().unwrap().to_string_lossy()
                ));
                qmlcachegen_file_paths.push(PathBuf::from(&qml_compiled_file));

                let specific_args = vec![
                    "--resource-path".to_string(),
                    qrc_resource_path.clone(),
                    "-o".to_string(),
                    qml_compiled_file.to_string_lossy().to_string(),
                    std::fs::canonicalize(file)
                        .unwrap()
                        .to_string_lossy()
                        .to_string(),
                ];

                let cmd = Command::new(qmlcachegen_executable)
                    .args(common_args.iter().chain(&specific_args))
                    .output()
                    .unwrap_or_else(|_| {
                        panic!(
                            "qmlcachegen failed for {} in QML module {uri}",
                            file.as_ref().display()
                        )
                    });
                if !cmd.status.success() {
                    panic!(
                        "qmlcachegen failed for {} in QML module {uri}:\n{}",
                        file.as_ref().display(),
                        String::from_utf8_lossy(&cmd.stderr)
                    );
                }
                qml_file_qrc_paths.push(qrc_resource_path);
            }

            let qmlcachegen_loader = qmlcachegen_dir.join("qmlcache_loader.cpp");
            let specific_args = vec![
                "--resource-name".to_string(),
                format!("qmlcache_{qml_uri_underscores}"),
                "-o".to_string(),
                qmlcachegen_loader.to_string_lossy().to_string(),
            ];

            // If there are no QML files there is nothing for qmlcachegen to run with
            if !qml_files.is_empty() {
                let cmd = Command::new(qmlcachegen_executable)
                    .args(
                        common_args
                            .iter()
                            .chain(&specific_args)
                            .chain(&qml_file_qrc_paths),
                    )
                    .output()
                    .unwrap_or_else(|_| panic!("qmlcachegen failed for QML module {uri}"));
                if !cmd.status.success() {
                    panic!(
                        "qmlcachegen failed for QML module {uri}:\n{}",
                        String::from_utf8_lossy(&cmd.stderr)
                    );
                }
                qmlcachegen_file_paths.push(PathBuf::from(&qmlcachegen_loader));
            }
        }

        let qml_plugin_dir = PathBuf::from(format!("{out_dir}/qt-build-utils/qml_plugin"));
        std::fs::create_dir_all(&qml_plugin_dir).expect("Could not create qml_plugin dir");

        // Run qmltyperegistrar
        let qmltyperegistrar_output_path =
            qml_plugin_dir.join(format!("{qml_uri_underscores}_qmltyperegistration.cpp"));

        // Filter out empty jsons
        let metatypes_json: Vec<_> = metatypes_json
            .iter()
            .filter(|f| {
                std::fs::metadata(f)
                    .unwrap_or_else(|_| {
                        panic!("couldn't open json file {}", f.as_ref().to_string_lossy())
                    })
                    .len()
                    > 0
            })
            .map(|f| f.as_ref().to_string_lossy().to_string())
            .collect();

        // Only run qmltyperegistrar if we have valid json files left out
        if !metatypes_json.is_empty() {
            let mut args = vec![
                "--generate-qmltypes".to_string(),
                qmltypes_path.to_string_lossy().to_string(),
                "--major-version".to_string(),
                version_major.to_string(),
                "--minor-version".to_string(),
                version_minor.to_string(),
                "--import-name".to_string(),
                uri.to_string(),
                "-o".to_string(),
                qmltyperegistrar_output_path.to_string_lossy().to_string(),
            ];
            args.extend(metatypes_json);
            let cmd = Command::new(qmltyperegistrar_executable)
                .args(args)
                .output()
                .unwrap_or_else(|_| panic!("qmltyperegistrar failed for {uri}"));
            if !cmd.status.success() {
                panic!(
                    "qmltyperegistrar failed for {uri}:\n{}",
                    String::from_utf8_lossy(&cmd.stderr)
                );
            }
        }

        // Generate QQmlEngineExtensionPlugin
        let qml_plugin_cpp_path = qml_plugin_dir.join(format!("{plugin_class_name}.cpp"));
        let include_path;
        {
            let mut declarations = Vec::default();
            let mut usages = Vec::default();

            let mut generate_usage = |return_type: &str, function_name: &str| {
                declarations.push(format!("extern {return_type} {function_name}();"));
                usages.push(format!("volatile auto {function_name}_usage = &{function_name};\nQ_UNUSED({function_name}_usage);"));
            };

            // This function is generated by qmltyperegistrar
            generate_usage("void", &format!("qml_register_types_{qml_uri_underscores}"));
            generate_usage(
                "int",
                &format!("qInitResources_qml_module_resources_{qml_uri_underscores}_qrc"),
            );

            if !qml_files.is_empty() && qmlcachegen_executable.is_some() {
                generate_usage(
                    "int",
                    &format!("qInitResources_qmlcache_{qml_uri_underscores}"),
                );
            }
            let declarations = declarations.join("\n");
            let usages = usages.join("\n");

            std::fs::write(
                &qml_plugin_cpp_path,
                format!(
                    r#"
#include <QtQml/qqmlextensionplugin.h>

// TODO: Add missing handling for GHS (Green Hills Software compiler) that is in
// https://code.qt.io/cgit/qt/qtbase.git/plain/src/corelib/global/qtsymbolmacros.h
{declarations}

class {plugin_class_name} : public QQmlEngineExtensionPlugin
{{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QQmlEngineExtensionInterface")

public:
    {plugin_class_name}(QObject *parent = nullptr) : QQmlEngineExtensionPlugin(parent)
    {{
        {usages}
    }}
}};

// The moc-generated cpp file doesn't compile on its own; it needs to be #included here.
#include "moc_{plugin_class_name}.cpp.cpp"
"#,
                ),
            )
            .expect("Failed to write plugin definition");

            let moc_product = self.moc(
                &qml_plugin_cpp_path,
                MocArguments::default().uri(uri.to_owned()),
            );
            // Pass the include directory of the moc file to the caller
            include_path = moc_product.cpp.parent().map(|path| path.to_path_buf());

            // Generate Initializer for static QQmlExtensionPlugin
            let plugin_init = Initializer {
                file: None,
                init_call: None,
                init_declaration: Some(format!(
                    r#"
#include <QtPlugin>
Q_IMPORT_PLUGIN({plugin_class_name});
"#
                )),
            };

            let rcc = self.qrc(&qrc_path);
            QmlModuleRegistrationFiles {
                // The rcc file is automatically initialized when importing the plugin.
                // so we don't need to treat it like an initializer here.
                rcc: rcc.file.unwrap(),
                qmlcachegen: qmlcachegen_file_paths,
                qmltyperegistrar: qmltyperegistrar_output_path,
                plugin: qml_plugin_cpp_path,
                plugin_init,
                include_path,
            }
        }
    }

    /// Run [rcc](https://doc.qt.io/qt-6/resources.html) on a .qrc file and save the output into [cargo's OUT_DIR](https://doc.rust-lang.org/cargo/reference/environment-variables.html).
    /// The path to the generated C++ file is returned, which can then be passed to [cc::Build::files](https://docs.rs/cc/latest/cc/struct.Build.html#method.file).
    /// This function also returns a String that contains the name of the resource initializer
    /// function.
    /// The build system must ensure that if the .cpp file is built into a static library, either
    /// the `+whole-archive` flag is used, or the initializer function is called by the
    /// application.
    pub fn qrc(&mut self, input_file: &impl AsRef<Path>) -> Initializer {
        let rcc_executable = self
            .qt_installation
            .try_find_tool(QtTool::Rcc)
            .expect("Could not find rcc");
        let input_path = input_file.as_ref();
        let output_folder = PathBuf::from(&format!(
            "{}/qt-build-utils/qrc",
            env::var("OUT_DIR").unwrap()
        ));
        std::fs::create_dir_all(&output_folder).expect("Could not create qrc dir");
        let output_path = output_folder.join(format!(
            "{}.cpp",
            input_path.file_name().unwrap().to_string_lossy(),
        ));
        let name = input_path
            .file_name()
            .unwrap()
            .to_string_lossy()
            .replace('.', "_");

        let cmd = Command::new(rcc_executable)
            .args([
                input_path.to_str().unwrap(),
                "-o",
                output_path.to_str().unwrap(),
                "--name",
                &name,
            ])
            .output()
            .unwrap_or_else(|_| panic!("rcc failed for {}", input_path.display()));

        if !cmd.status.success() {
            panic!(
                "rcc failed for {}:\n{}",
                input_path.display(),
                String::from_utf8_lossy(&cmd.stderr)
            );
        }

        let qt_6_5 = Version::new(6, 5, 0);
        let init_header = if self.qt_installation.version() >= qt_6_5 {
            // With Qt6.5 the Q_INIT_RESOURCE macro is in the QtResource header
            "QtCore/QtResource"
        } else {
            "QtCore/QDir"
        };
        Initializer {
            file: Some(output_path),
            init_call: Some(format!("Q_INIT_RESOURCE({name});")),
            init_declaration: Some(format!("#include <{init_header}>")),
        }
    }

    /// Run [rcc](https://doc.qt.io/qt-6/resources.html) on a .qrc file and return the paths of the sources
    pub fn qrc_list(&mut self, input_file: &impl AsRef<Path>) -> Vec<PathBuf> {
        let rcc_executable = self
            .qt_installation
            .try_find_tool(QtTool::Rcc)
            .expect("Could not find rcc");

        // Add the qrc file contents to the cargo rerun list
        let input_path = input_file.as_ref();
        let cmd_list = Command::new(rcc_executable)
            .args(["--list", input_path.to_str().unwrap()])
            .output()
            .unwrap_or_else(|_| panic!("rcc --list failed for {}", input_path.display()));

        if !cmd_list.status.success() {
            panic!(
                "rcc --list failed for {}:\n{}",
                input_path.display(),
                String::from_utf8_lossy(&cmd_list.stderr)
            );
        }

        String::from_utf8_lossy(&cmd_list.stdout)
            .split('\n')
            .map(PathBuf::from)
            .collect()
    }
}
