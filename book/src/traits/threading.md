<!--
SPDX-FileCopyrightText: 2023 KlarÃ¤lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
SPDX-FileContributor: Andrew Hayzen <andrew.hayzen@kdab.com>

SPDX-License-Identifier: MIT OR Apache-2.0
-->

# CxxQtThread

<!--
TODO: check and rewrite
-->

The general concept for threading is that when Rust code is being executed a lock has been acquired on the C++ side to prevent Rust code being executed from multiple threads.

This means that Rust code, such as invokables and properties, which are directly called from C++ are executed on the Qt thread.

> Note that a recursive mutex is used internally, this allows for signals to be emitted and then call slots on the same object without deadlocks.

To achieve safe multi-threading on the Rust side we use an `CxxQtThread<T>`.
A `CxxQtThread<T>` represents a reference to the Qt thread that the QObject of type `T` lives in.
When a new Rust thread is started (e.g. in an invokable) the `CxxQtThread<T>` can be moved into the thread to later update the QObject in a thread safe manner.

When the Rust thread needs to update a value in the QObject it can then queue a closure to the thread.
This closure will be executed on the thread the QObject lives in while holding a lock on the Rust object.
Updating the QObject is then thread-safe.



`CxxQtThread<T>` is used for easy threading with QObjects.
The QObjects generated by CXX-Qt are neither [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) nor [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html).
Therefore they may not be passed between threads nor accessed from multiple threads.

`CxxQtThread<T>` is an object that allows you to queue closures safely onto the Qt thread that the `qobject::T` lives on.
This object is `Send` and can therefore be moved into other threads.
It allows you to queue events from a different thread to occur on the thread of the `qobject::T` by using the Qt Event Loop.

First threading needs to be enabled for the QObject by using `impl cxx_qt::Threading for T {}`.

```rust,ignore,noplayground
{{#include ../../../examples/qml_features/rust/src/threading.rs:book_qt_thread}}
```

Note that locking must not be disabled for the object (eg `unsafe impl cxx_qt::Locking for qobject::T`) for `cxx_qt::Threading` to be allowed.

Then to access the `CxxQtThread<T>` use the `qt_thread(&self)` method on a QObject.

```rust,ignore,noplayground
{{#include ../../../examples/qml_features/rust/src/threading.rs:book_qt_thread}}
```

The `CxxQtThread<T>` can then be moved into any Rust thread.
The `queue` function can then be used to queue a [closure](https://doc.rust-lang.org/book/ch13-01-closures.html)  onto the Qt event loop:
``` rust,ignore,noplayground
fn queue(&self, f: F) -> Result<(), cxx::Exception>
  where F: impl FnOnce(ctx: Pin<&mut TQt>) + Send + 'static
```
The first argument of the closure is a pinned mutable reference to the `qobject::T`.
With this parameter, you can then update the QObject to reflect any state changes that have occured in the background thread.

```rust,ignore,noplayground
{{#include ../../../examples/qml_features/rust/src/threading.rs:book_qt_thread_queue}}
```
[Full example](https://github.com/KDAB/cxx-qt/blob/main/examples/qml_features/rust/src/threading.rs)
