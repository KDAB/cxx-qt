<!--
SPDX-FileCopyrightText: 2022 KlarÃ¤lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
SPDX-FileContributor: Leon Matthes <leon.matthes@kdab.com>

SPDX-License-Identifier: MIT OR Apache-2.0
-->

# Our first CXX-Qt module

As with all things Rust, we'll first want to create a cargo project.
```bash
cargo new --lib qml-minimal
```
Note the `--lib` option here.
It is important that we create a static library in Rust, rather than an executable.
We'll discuss details of this later, when we [integrate our Rust project with CMake](./5-cmake-integration.md).

As outlined in the previous section, to define a new QObject subclass, we'll need to create a Rust module.
So let's go into the `src/lib.rs` file.
We'll modify this file until it looks like this:

```rust,ignore
{{#include ../../../examples/qml_minimal/src/lib.rs:book_cxx_qt_module}}
```

This is a lot to take in, so let's go one step at a time.
Starting with the module definition:
```rust,ignore
{{#include ../../../examples/qml_minimal/src/lib.rs:book_bridge_macro}}
```

Because we add the `#[cxx_qt::bridge(namespace = "cxx_qt::my_object")]` macro to the module definition,
CXX-Qt will look inside the module for further macros which can define the QObject.

For the `#[cxx_qt::bridge(namespace = "cxx_qt::my_object")]` macro to work, we first need to define the data that will live in the new C++ object.
This is done with the `Data` struct:
```rust,ignore
{{#include ../../../examples/qml_minimal/src/lib.rs:book_data_struct}}
```
That means the newly created QObject subclass will have two properties as members: `number` and `string`. For names that contain multiple words, like `my_number`, CXX-Qt will perform the snake_case to camelCase conversion to fit with C++/QML naming conventions.

Note that the data types we use here are normal Rust data types.
CXX-Qt will automatically convert these types to their C++/Qt equivalent.
In our case that means:
- `number: i32` -> `int number`
- `string: UniquePtr<QString>` -> `QString string`\
For more details on the available types, see the [Qt types page](../concepts/types.md).

You might have also noticed the `#[derive(Default)]` here.
Currently the Data struct needs to always be default-constructable.
The data returned by the implementation of `Default` will be converted to the appropriate C++ types and assigned to the properties of any newly-constructed `MyObject` instance.
Alternatively, we could also provide our own `Default` implementation for Data.

Now that we've defined the data that will live on the C++ side of things, let's take a look at the Rust side:
```rust,ignore
{{#include ../../../examples/qml_minimal/src/lib.rs:book_rustobj_struct}}
```
The name of this struct is used as the name of the C++ QObject subclass, in our case this is just an empty struct.
However, the `#[cxx_qt::qobject]` marked struct could contain any data we want.
It is not converted into a C++ class, so it isn't limited to the Qt-compatible types that the `Data` struct is.

An important point to note here is that the `#[cxx_qt::qobject]` marked struct, like the `Data` struct must implement the `Default` trait.
Every instance of the `MyObject` class will automatically create a corresponding `#[cxx_qt::qobject]` marked struct instance by using the `Default` trait.

Just because the `#[cxx_qt::qobject]` marked struct struct doesn't contain any data, that still doesn't mean its not an important part of our `MyObject` class.
That is because it actually defines the behavior of our class through its `impl`:
```rust,ignore
{{#include ../../../examples/qml_minimal/src/lib.rs:book_rustobj_impl}}
```

In our case, we define two new functions:
- `increment_number`
    - Increments the number of the `MyObject`.
    - As the number lives on the C++ side, it uses a `CppObj` wrapper which is generated by CXX-Qt and has the appropriate setters and getters for each property.
    - The name will be converted to `incrementNumber` in C++.
- `say_hello`
    - Prints a provided number and string.
    - The name will be converted to `sayHello` in C++.

Both functions are marked with the `#[invokable]` macro, which means the functions will be added to the C++ code of `MyObject` and will be callable from QML as well.

Apart from functions marked with the `#[invokable]` macro, the `#[cxx_qt::qobject]` marked struct impl is just a normal Rust struct impl and can contain normal Rust functions, which the invokable functions can call as usual.

And that's it. We've defined our first QObject subclass in Rust. That wasn't so hard, was it?

Now let's get to [using it in Qt](./3-exposing-to-qml.md).
